# 31.03

- Выполнен 4 модуль, теперь машинка проезжает до конца и не ломается (кружится в одном месте) в рандомных точках 
- Хотелось бы получить обратную связь по поводу того, что не так в 3 модуле 
- После засчитования модулей и получения темы проекта будем в нем разбираться


# 07.04

- Выполнили 3 модуль
- Выбрали тему проекта
- Вопрос: что нужно реализовать в "Терминаторе TLS"?

# 12.04
- Сделали шаблон класса TLS терминатора (без шифрования), подключили его между блоками системы планирования заданий и связи. Предположили (как выяснится позже, ошибочно), что нужно шифровать сообщения между блоками TLS_terminator и CommunicationGateway.

# 13.04
- Упростили маршрут для более быстрой проверки работоспособности реализации

# 05.05
- Разобрались с основами криптографии (алгоритмы симметричного/асимметричного шифрования, публичные, приватные и секретные ключи, цифровые подписи и цифровые сертификаты, алгоритм обмена секретным ключом Диффи -- Хеллмана), а также с тем, как должен работать TLS терминатор.
## Описание будущей реализации
TLS терминатор кодирует алгоритмом симметричного шифрования сообщения между блоками. То есть существует некий алгоритм, который по одному и тому же ключу может как зашифровать сообщение, так и расшифровать уже зашифрованное:
```
alg(message, secret_key)            --> encrypted_message
alg(encrypted_message, secret_key)  --> message
```
Так, злоумышленник извне не может узнать содержимое "переписки": он видит только зашифрованные сообщения.
Чтобы достичь такого эффекта, соответственно, нужно каким-то образом сделать так, чтобы оба блока имели одинаковый секретный ключ.

Сделать так, чтобы оба блока договорились об одном и то же секретным ключе, можно, например, используя классический алгоритм Диффи -- Хеллмана (используется его "учебный" вариант на основе двух простых чисел, а не более современный и сложный с использованием положения точки на эллиптической кривой).
### Алгоритм Диффи -- Хеллмана
Сначала создаются два больших публичных простых числа, назовём их P1 и P2. Для примера установим, что P1 = 7 и P2 = 11.

Далее участники коммуникаций (допустим, Alice и Bob) выбирают себе какие-то 2 числа будем считать, что Alice выбрала a = 3, а Bob -- b = 5. Эти числа участники никому не сообщают (они секретные).

Далее Alice и Bob вычисляют числа A и B:
```
A = P1^a % P2 = ... = 2
B = P1^b % P2 = ... = 10
```
... и делятся этими числами друг с другом (публично).

Когда участники поделились числами A и B, остался последний этап: вычислить значение для K -- общего секретного ключа:
```
Alice:  K = B^a % P2 = ... = 10
Bob:    K = A^b % P2 = ... = 10
```
Получается, Alice и Bob смогли вычислить одинаковое значение общего секретного ключа -- K = 10. Математически доказано, что третий участник на основе публичных значений (P1, P2, A и B) никак не сможет получить то же самое значение ключа.

Однако описанный алгоритм не защищает от ситуации "man-in-the-middle": когда злоумышленник перехватывает передачу значений A и B и подменяет их на свои A_fake и B_fake. Тогда он сможет скомпрометировать (и читать, и изменять) все сообщения.

Чтобы избежать такой ситуации, используютсся цифровые сертификаты -- фактически, просто кортежи {public_key, digital_signature, contact_info}, которые точно удостоверяют, что публичный принадлежит принадлежит тому или иному участнику сети.

Модифицированная версия Диффи -- Хеллмана (с использованием описанных цифровых сертификатов) используется в SSL (как следствие, и в основанном на SSL протоколе TLS). Там могут быть и другие алгоритмы для обмена общим секретным ключом, но мы рассмотрим именно вариант ДХ.

### Работа SSL/TLS (случай Диффи -- Хеллмана)
Обозначим одного участника общения за `client`, а другого -- за `server`.

Первым делом `client` отсылает серверу сообщение `client_hello`, которое выглядит вот так:
```
SSL version:    TLS 1.0
Random:         5cfa26...
session_id:     0 (т.к. новая сессия)
cipher_suite:   alg() = {...}, hash() = {..., key_exchange_alg = {Diffie -- Hellman, ...}
```
В поле `cipher_suite` указывается тот набор алгоритмов шифрования, хеширования и обмена ключами, который поддерживается у клиента. Впоследствии сервер выберет по одному алгоритму из каждого набора.

Сервер, прочитав это сообщение, выбирает соответствующие алгоритмы и отсылает клиенту сообщение `server_hello`:
```
your_ssl_version_is_good:   true,
random:                     c3810ed...,
cipher_suite:               alg() = ..., hash() = ..., key_exchange_alg = DH,
digital_certificate:        {server_public_key, signature, server_contact_info}.
```
Сразу за этим сообщение сервер также отсылает сообщение `server_key_exchange`:
```
sign({P1=7, P2=11, S=P1^s % P2}, server_private_key)
```
Так как в сообщении до этого был передан цифровой сертификат с `server_public_key`, то `client`, получив сообщение `server_key_exchange`, точно сможет удостовериться, что оно пришло именно от сервера, а не зломышленника (ведь для подписи этого сообщения использовался `server_private_key`).

После этого у клиента появляются достоверные значения {P1, P2, S}, на основе которых он сможет вычислить значение K. Сервер, соответственно, тоже может вычислить то же самое значение `K`.

Далее число K преобразовывается в конечныый ключ:
```
K --> master_secret_key --> session_key
```
Готово! И у сервера, и у клиента есть общий `session_key`, притом, во-первых, никто больше не знает, что это за ключ, а во-вторых, точно известно, что сервер это действительно сервер, а не зломышленник.

Формально дальше идут ещё несколько сообщений в духе `change_cipher_spec`:
```
"From now on, I'll speak encrypted."
```
... или последнего сообщения рукопожатия -- `finished`:
```
alg(hash(cl_hello, sr_hello, sr_key_ex, cl_key_ex), session_key)
```
Но мы их рассматривать уже не будем.
# 14.05
- Реализовали шифрование сообщений между системой планирования заданий (`client`) и TLS терминатором (`server`) при помощи `cryptography.fernet`.

На данном этапе мы предполагаем, что секретный ключ каким-то образом уже был установлен (то есть не делаем само рукопожатие с сообщениями `cl_hello`, `sr_hello` и т.д.). Это предположение выражено в том, что и блок `MissionPlanner`, и блок `TLS_terminator` просто берут значение ключа из файла `secret_key`.

# 16.05
- Реализовали весь процесс рукопожатия с созданием цифрового сертификата для сервера, его подписанием при помощи `root_CA` (корневой организации, которая должна ставить подписи на цифровых сертификатах) и обменом сообщениями `cl_hello`, `sr_hello`, ..., в результате которого и у блока `MissionPlanner`, и у блока `TLS_terminator` появляется одно и то же число `K`. На основе этого числа оба блока вычисляют `session_key`, который в дальнейшем используют для шифрования/расшифровки всех сообщений.

# 17.05
Написали несколько тестов:
- `test_certificate_validation` для проверки того, что вся работа по проверке цифровой подписи на публчном ключе в цифровом сертификате проходит правильно.
- `test_tls_terminator_initialization` для проверки того, что инициализация класса `TLS_terminator` проходит верно (ведь этот блок является ещё и блоком `server` в TLS-общении, так что для него, например, точно должны корректно создаваться цифровой сертификат и `server_private_key`).
- `test_mission_planner_initialization` для проверки того, что инициализация класса MissionPlanner также проходит верно (тут более простая проверка, которая сделана для того, чтобы точно удостовериться, что оба блока, участвующие в общении, были корректно созданы и имеют корретные поля).
- `test_tls_terminator_process_client_hello` для проверки того, что при получении `client_hello` блок `TLS_terminator` корретно его орабатывает и отсылает назад правильно сконструированное `server_hello`.
- `test_mission_encryption_decryption` для проверки того, что блок Fernet корректно шифрует/расшифровывает сообщения.
- `test_full_tls_handshake_simulation` для проверки того, что полное рукпоожатие (`client_hello`, `server_hello`, `server_key_exchange`, `finish_handshake`) отрабатывает корретно, то есть что одно сообщение цепочки корректно вызывает следующие и в финале они приводят к корректному установлению ключей, а значит, и к корректному установлению TLS-соединения.